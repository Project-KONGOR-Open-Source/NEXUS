namespace KONGOR.ChatServer.Matchmaking;

public class MatchmakingGroup
{
    public enum GroupState
    {
        WaitingToStart,
        LoadingResources,
        InQueue,
    }

    public enum TournamentMode
    {
        None = 0,
        GrimmsCrossing = 1,
    }

    public class Participant
    {
        public readonly int AccountId;
        public readonly string Name;
        public byte LoadingStatus;
        public readonly string ChatNameColor;
        public readonly string AccountIcon;
        public readonly bool TopOfTheQueue;
        public readonly bool ProtectedParticipant;

        public Participant(Account account, bool topOfTheQueue, bool protectedParticipant)
        {
            AccountId = account.AccountId;
            Name = account.NameWithClanTag;
            ChatNameColor = account.SelectedChatNameColourCode;
            AccountIcon = account.SelectedAccountIconCode;

            LoadingStatus = 0;
            TopOfTheQueue = topOfTheQueue;
            ProtectedParticipant = protectedParticipant;
        }
    }

    private static int NextGroupId = 0;

    private int GroupId = ++NextGroupId;
    public readonly List<Participant> Participants = new();

    private byte GroupType { get; set; }
    internal TMMGameType GameType { get; set; }
    internal string GameModes { get; set; }
    public string Regions { get; set; }
    private byte Ranked { get; set; }
    private byte MatchFidelity { get; set; }
    private byte BotDifficulty { get; set; }
    private byte RandomizeBots { get; set; }
    private Timer Timer { get; set; }
    private GroupState State { get; set; } = GroupState.WaitingToStart;
    private HashSet<int> InvitedAccountIds { get; } = new();
    internal ChatChannel? ChatChannel { get; private set; }
    private int MaxGroupSize;

    // The TMMGroup that was registered with GameFinder if the status is In-Queue, and null otherwise.
    internal TMMGroup? TMMGroup;

    internal List<MatchmakingGroupPlayerInfo> PlayersInfo;
    internal float TournamentRating;
    internal int TournamentTeamID;

    public enum GroupUpdateType
    {
        GroupCreated = 0,
        Full = 1,
        Partial = 2,
        ParticipantAdded = 3,
        ParticipantRemoved = 4,
        ParticipantKicked = 5,
    }

    public MatchmakingGroup(byte groupType, TMMGameType gameType, string gameModes, string regions, byte ranked, byte matchFidelity, byte botDifficulty, byte randomizeBots, int maxGroupSize)
    {
        GroupType = groupType;
        GameType = gameType;
        GameModes = gameModes;
        Regions = regions;
        Ranked = ranked;
        MatchFidelity = matchFidelity;
        BotDifficulty = botDifficulty;
        RandomizeBots = randomizeBots;
        MaxGroupSize = maxGroupSize;

        Timer = new(TimerCallback, this, Timeout.Infinite, Timeout.Infinite);
    }

    public bool Add(
        Account account,
        out ChatServerProtocol.MatchmakingFailedToJoinReason failureReason)
    {
        if (Participants.Any(participant => participant.AccountId == account.AccountId))
        {
            // Avoid adding twice.
            // Must still initialize failureReason even if we return true, but it should be ignored.
            failureReason = ChatServerProtocol.MatchmakingFailedToJoinReason.Leaver;
            return true;
        }

        int participantCount = Participants.Count;
        if (participantCount >= MaxGroupSize)
        {
            // Cannot add any more.
            failureReason = ChatServerProtocol.MatchmakingFailedToJoinReason.GroupFull;
            return false;
        }

        if (State != GroupState.WaitingToStart)
        {
            // Don't interrupt queue.
            failureReason = ChatServerProtocol.MatchmakingFailedToJoinReason.AlreadyQueued;
            return false;
        }

        Participant? participant = new Participant(
            account,
            topOfTheQueue: account.AccountType == AccountType.VIP || account.AccountType == AccountType.Staff,
            protectedParticipant: account.AccountType == AccountType.VIP || account.AccountType == AccountType.Streamer);
        Participants.Add(participant);

        if (participantCount == 0)
        {
            // First connected Account become the Leader.
            BroadcastUpdate(MatchmakingGroup.GroupUpdateType.GroupCreated);
        }
        else
        {
            // Create a chat channel for the group if there are more than one Participants.
            if (ChatChannel == null)
            {
                string channelName = "Group #" + GroupId;
                ChatChannel? chatChannel = KongorContext.ChatChannels.ChatChannelByName(channelName);
                ChatServerProtocol.ChatChannelFlags channelFlags = ChatServerProtocol.ChatChannelFlags.CannotBeJoined;
                if (chatChannel != null)
                {
                    chatChannel.RemoveEveryone();
                    chatChannel.Flags = channelFlags;
                }
                else
                {
                    chatChannel = new ChatChannel(channelName, "TMM Group Chat", channelFlags);
                    KongorContext.ChatChannels.Add(chatChannel);
                }

                ChatChannel = chatChannel;
                chatChannel.AddAccountIds(Participants.Select(participant => participant.AccountId));
            }
            else
            {
                // ChatChannel already exists, join it.
                ChatChannel.AddAccount(account, KongorContext.ConnectedClients[account.AccountId]);
            }

            BroadcastUpdate(MatchmakingGroup.GroupUpdateType.Full);
        }

        // Must still initialize failureReason even if we return true, but it should be ignored.
        failureReason = ChatServerProtocol.MatchmakingFailedToJoinReason.Leaver;
        return true;
    }

    public void RemoveBySlot(int slot, string reason)
    {
        if (Participants.Count <= slot) return;

        LeaveQueue(initiatedByGameFinder: false, reason);

        Participant participant = Participants[slot];

        // Broadcast BEFORE removing so that the participant that is being removed is notified, too.
        BroadcastUpdate(GroupUpdateType.ParticipantKicked, participant.AccountId);

        // Actually remove.
        Participants.RemoveAt(slot);

        // Broadcast again to get the correct slots
        BroadcastUpdate(GroupUpdateType.ParticipantKicked, participant.AccountId);

        // And reset their matchmaking group.
        ConnectedClient client = KongorContext.ConnectedClients[participant.AccountId];
        client.MatchmakingGroup = null;
    }

    public void DisbandIfSoloQueueDueToMatchStart()
    {
        // We want to disband solo Q when the match starts, but we don't want to display a notification on top of the Game Started interface.
        // Note: we don't need to call LeaveGroup() because it's the GameFinder that tells us to disband, and at this point the group is already
        // removed from the Queue.
        if (Participants.Count == 1)
        {
            int accountId = Participants[0].AccountId;
            ConnectedClient client = KongorContext.ConnectedClients[accountId];
            client.MatchmakingGroup = null;
            Participants.Clear();
        }
    }

    public void Remove(ConnectedClient client, Account account, string reason)
    {
        LeaveQueue(initiatedByGameFinder: false, reason);

        if (Participants.Count > 1 && Participants[0].AccountId == account.AccountId)
        {
            // Reassign Leader first.
            Participant pastLeader = Participants[0];
            Participants.RemoveAt(0);
            Participants.Add(pastLeader);

            // Notify the players about the leader change.
            BroadcastUpdate(GroupUpdateType.Full, -1);
        }

        BroadcastUpdate(GroupUpdateType.ParticipantRemoved, account.AccountId);

        Participants.RemoveAll(participant => participant.AccountId == account.AccountId);
        client.MatchmakingGroup = null;

        if (ChatChannel != null)
        {
            ChatChannel.RemoveAccount(client, account.AccountId, true);
        }
    }

    public void EnterQueue()
    {

        /*
        -- Placement Group Queue Restriction
        bool playersDidntCompletePlacements = false;
        int index = 0;

        if (Participants.Count > 1)
        {
            List<string> playersWithoutRank = new();
            foreach (MatchmakingGroupPlayerInfo playerInfo in PlayersInfo)
            {
                if (playerInfo.IsInPlacements)
                {
                    playersWithoutRank.Add(playerInfo.AccountName);
                }
                index++;
            }
            if (playersWithoutRank.Count > 0)
            {
                KongorContext.ConnectedClients[Participants[0].AccountId].SendResponse(
                    new ErrorMessageResponse(
                        $"You need to have a rank (e.g.: Bronze, Silver, Gold etc) in {GetMapName(GameType)} to play with the group. To obtain a rank, you need to play 6 matches without the group. Players {string.Join(',', playersWithoutRank)} in your group didn't complete placement matches for {GetMapName(GameType)} and don't have a rank yet!"
                    )
                );
                return;
            }
        }
        */

        float highestMMR = PlayersInfo.Max(info => info.Rating);
        float lowestMMR = PlayersInfo.Min(info => info.Rating);
        float combinedMMR = PlayersInfo.Sum(info => info.Rating);
        float averageMMR = combinedMMR / PlayersInfo.Count();
        float teamApproximation = combinedMMR + averageMMR * (5 - PlayersInfo.Count());
        float bottomFourMMR = teamApproximation - highestMMR;
        if (highestMMR - bottomFourMMR / 4 >= 150)
        {
            KongorContext.ConnectedClients[Participants[0].AccountId].SendResponse(
                new ErrorMessageResponse($"MMR disparity in your group is too high with highest MMR being {highestMMR} and lowest MMR being {lowestMMR}. This will lead to either unbalanced games or very long queue times, and thus currently disallowed.")
            );
            return;
        }

        // Only allow queueing for Casual in TH and SEA regions.
        if (GameType == TMMGameType.CAMPAIGN_CASUAL || GameType == TMMGameType.CASUAL)
        {
            string[] regions = Regions.Split("|");
            int numAllowedRegions = 0;
            if (regions.Contains("TH"))
            {
                ++numAllowedRegions;
            }

            if (regions.Contains("SEA"))
            {
                ++numAllowedRegions;
            }

            if (regions.Contains(""))
            {
                // Workaround for "TH|" being split into "TH" and "".
                ++numAllowedRegions;
            }

            if (regions.Length != numAllowedRegions)
            {
                // Other regions selected other than TH or SEA, don't allow to queue with them enabled.
                KongorContext.ConnectedClients[Participants[0].AccountId].SendResponse(
                    new ErrorMessageResponse("Casual mode is only available to play in Thailand and SEA regions.")
                );
                return;
            }
        }

        // Leader is ready, advance the state.
        State = GroupState.LoadingResources;

        // Boardcast an update to indicate that everyone is ready.
        BroadcastUpdate(GroupUpdateType.Partial);

        // Start loading resources.
        Broadcast(new MatchmakingStartLoadingResponse());

        // Fire a timer 1 second from now, and every second thereafter.
        Timer.Change(1000, 1000);
    }

    public void UpdateParticipantReadyStatus(Account account, List<MatchmakingGroupPlayerInfo> playersInfo, float tournamentRating, byte readyStatus)
    {
        if (account.AccountId != Participants[0].AccountId)
        {
            // Ignore. There is no UI for ready so everyone is ready except Leader
            // who starts the game search manually.
            return;
        }

        this.PlayersInfo = playersInfo;
        this.TournamentRating = tournamentRating;
        if (readyStatus != 0)
        {
            EnterQueue();
        }
    }

    internal bool AddToGameFinderQueue(long timestampWhenJoinedQueue)
    {
        Dictionary<int, int>? pingInformation;
        if (Regions == "AUTO" || Regions == "AUTO|")
        {
            // If the region is auto, obtain ping information for the group.
            pingInformation = CombinePingInformation(PlayersInfo.Select(info => info.PingInformation).ToList());
            if (pingInformation.Count == 0)
            {
                // No ping information is available.
                KongorContext.ConnectedClients[Participants[0].AccountId].SendResponse(
                    new ErrorMessageResponse("Not all players have reported server pings. Please toggle AUTO region on/off and try again.")
                );
                return false;
            }
        }
        else
        {
            pingInformation = null;
        }

        if (Participants.Count != PlayersInfo.Count())
        {
            KongorContext.ConnectedClients[Participants[0].AccountId].SendResponse(
                new ErrorMessageResponse("Internal error: couldn't obtain MMR of all players.")
            );
            return false;
        }

        ProtocolResponse response;
        ConnectedClient leader = KongorContext.ConnectedClients[Participants[0].AccountId];
        if (leader.TimestampWhenTimePreviouslySpentInQueueExpire > timestampWhenJoinedQueue)
        {
            long timePreviouslySpentInQueue = leader.TimePreviouslySpentInQueue;
            timestampWhenJoinedQueue -= timePreviouslySpentInQueue;
            response = new MatchmakingGroupRejoinQueueResponse(Convert.ToInt32(timePreviouslySpentInQueue / Stopwatch.Frequency));

        }
        else
        {
            response = new MatchmakingGroupJoinQueueResponse();
        }

        // Create an immutable snapshot of our MatchmakingGroup.
        TMMGroup = ToTMMGroup(timestampWhenJoinedQueue, pingInformation);
        if (TMMGroup == null) return false;

        Broadcast(response);

        // Register it with the GameFinder.
        GameFinder.AddToQueue(TMMGroup);

        // We are now in the queue.
        State = GroupState.InQueue;

        return true;
    }

    internal TMMGroup? ToTMMGroup(long timestampWhenJoinedQueue, Dictionary<int, int>? pingInformation)
    {
        bool isLookingForPlacementMatch;
        if (Participants.Count == 1)
        {
            MatchmakingGroupPlayerInfo playerInfo = PlayersInfo[0];
            isLookingForPlacementMatch = GameType switch
            {
                TMMGameType.CAMPAIGN_NORMAL => playerInfo.IsInPlacements,
                TMMGameType.NORMAL => playerInfo.IsInPlacements,
                TMMGameType.CAMPAIGN_CASUAL => playerInfo.IsInPlacements,
                TMMGameType.CASUAL => playerInfo.IsInPlacements,
                TMMGameType.MIDWARS => playerInfo.IsInPlacements,
                TMMGameType.REBORN_UNRANKED_NORMAL => false,
                TMMGameType.REBORN_UNRANKED_CASUAL => false,
                _ => throw new Exception($"Unknown Game Type: {GameType}"),
            };
        }
        else
        {
            // Group is never looking for a placement match.
            isLookingForPlacementMatch = false;
        }

        HashSet<string> gameModes = SplitByPipeAndRemoveEmpty(GameModes);
        TournamentMode tournamentMode = TournamentMode.None;
        if (gameModes.Remove("tgc"))
        {
            if (Participants.Count != 3)
            {
                KongorContext.ConnectedClients[Participants[0].AccountId].SendResponse(
                    new ErrorMessageResponse(
                        $"To play Tournament Qualifiers on Grimm's Grossing, you need to join the queue with a group of 3. Current group size is {Participants.Count}."
                    )
                );
                return null;
            }
            tournamentMode = TournamentMode.GrimmsCrossing;
        }

        // Use ping threshold that is set by the leader.
        int inflatedPingThreshold = KongorContext.ConnectedClients[Participants[0].AccountId].InflatedPingThreshold;
        if (pingInformation != null)
        {
            int pingThreshold = inflatedPingThreshold - 50;
            var managerIdsBelowThreshold = pingInformation.Where(x => x.Value <= pingThreshold).Select(x => x.Key).ToList();
            foreach (var playerInfo in PlayersInfo)
            {
                if (KongorContext.ConnectedClients.TryGetValue(playerInfo.AccountId, out var client))
                {
                    var pings = client.PingInformation;

                    string message = string.Format("The following servers will be used to find the match (the group's ping threshold is {0}): ", inflatedPingThreshold);
                    //string excluded = "";
                    foreach (var (managerId, ping) in pings)
                    {
                        if (!managerIdsBelowThreshold.Contains(managerId))
                        {
                            /*
                            string excludedManagerName;
                            lock (SharedContext.ConnectedManagers)
                            {
                                if (SharedContext.ConnectedManagers.TryGetValue(managerId, out var manager))
                                {
                                    excludedManagerName = manager.Name.Length > 2 ? manager.Name.Substring(0, manager.Name.Length - 2) : manager.Name;
                                }
                                else
                                {
                                    excludedManagerName = string.Format("Unknown server id {0}", managerId);
                                }
                            }
                            excluded = string.Format("{0}{1} (ping {2}), ", excluded, excludedManagerName, ping);
                            */
                            continue;
                        }

                        string pingString;
                        int inflatedPing = ping + 50;
                        if (inflatedPing > inflatedPingThreshold)
                        {
                            // BUG
                            pingString = string.Format("{0}!!!", inflatedPing);
                        }
                        else
                        {
                            pingString = inflatedPing.ToString();
                        }

                        string managerName;
                        lock (SharedContext.ConnectedManagers)
                        {
                            if (SharedContext.ConnectedManagers.TryGetValue(managerId, out var manager))
                            {
                                managerName = manager.Name.Length > 2 ? manager.Name.Substring(0, manager.Name.Length - 2) : manager.Name;
                            }
                            else
                            {
                                managerName = string.Format("Server id {0}", managerId);
                            }
                        }
                        message = string.Format("{0}{1} (ping {2}), ", message, managerName, pingString);
                    }

                    client.SendResponse(new WhisperResponse("Matchmaking", message));
                }
            }
        }
        return new TMMGroup(
            accountInfo: PlayersInfo,
            groupMMR: PlayersInfo.Select(info => info.Rating).Sum(),
            lowestMMR: PlayersInfo.Select(info => info.Rating).Min(),
            highestMMR: PlayersInfo.Select(info => info.Rating).Max(),
            tournamentMode: tournamentMode,
            tournamentMMR: TournamentRating,
            regions: SplitByPipeAndRemoveEmpty(Regions),
            gameType: GameType,
            gameModes: SplitByPipeAndRemoveEmpty(GameModes),
            timestampWhenJoinedQueue: timestampWhenJoinedQueue,
            isLookingForPlacementMatch: isLookingForPlacementMatch,
            pingInformation: pingInformation,
            inflatedPingThreshold: inflatedPingThreshold,
            matchmakingGroup: this,
            topOfTheQueue: Participants.Any(participant => participant.TopOfTheQueue),
            protectedGroup: Participants.Any(participant => participant.ProtectedParticipant)
        );
    }

    public void UpdateParticipantLoadingStatus(Account account, byte loadingStatus)
    {
        bool everyoneLoaded = true;
        foreach (Participant participant in Participants)
        {
            if (participant.AccountId == account.AccountId)
            {
                participant.LoadingStatus = loadingStatus;
            }
            if (participant.LoadingStatus != 100)
            {
                everyoneLoaded = false;
            }
        }

        if (everyoneLoaded && State == GroupState.LoadingResources)
        {
            // Register the Group with the GameFinder.
            if (!AddToGameFinderQueue(timestampWhenJoinedQueue: Stopwatch.GetTimestamp()))
            {
                // Failed to join the queue, go back to WaitingToStart state.
                State = GroupState.WaitingToStart;
                BroadcastUpdate(GroupUpdateType.Partial);
                return;
            }

            // If we want to broadcast expected time in queue, we can:
            Broadcast(new MatchmakingGroupQueueUpdateResponse(
                updateType: 11,
                averageTimeInQueueInSeconds: 42
            ));

            // Don't trigger Timer again, for now. But before we do so, send an update.
            BroadcastUpdate(GroupUpdateType.Partial);
            Timer.Change(Timeout.Infinite, Timeout.Infinite);
        }
    }

    public void NotifyRemovedFromQueue()
    {
        // Update the state.
        State = GroupState.WaitingToStart;

        // Send the state change event.
        BroadcastUpdate(GroupUpdateType.Partial);

        // Dispatch an event notifying all participants that the group left the queue.
        // NOTE: Order here matters. If we dispatch MatchmakingGroupLeaveQueueResponse() event first,
        // there is a bug where a loading screen is briefly visible.
        Broadcast(new MatchmakingGroupLeaveQueueResponse());
    }

    public void LeaveQueue(bool initiatedByGameFinder, string reason)
    {
        switch (State)
        {
            case GroupState.WaitingToStart:
                return;
            case GroupState.LoadingResources:
                // Don't trigger Timer again, for now.
                Timer.Change(Timeout.Infinite, Timeout.Infinite);
                break;
            case GroupState.InQueue:
                // Remove the group from the GameFinder.
                if (TMMGroup != null)
                {
                    if (!initiatedByGameFinder)
                    {
                        GameFinder.RemoveFromQueue(TMMGroup, reason);
                    }

                    ConnectedClient leaderClient = KongorContext.ConnectedClients[Participants[0].AccountId];
                    long now = Stopwatch.GetTimestamp();

                    // Remember how long the Leader has spent in queue.
                    leaderClient.TimePreviouslySpentInQueue = now - TMMGroup.TimestampWhenJoinedQueue;

                    // Expire in 7 minutes.
                    leaderClient.TimestampWhenTimePreviouslySpentInQueueExpire = now + Stopwatch.Frequency * 60 * 7;

                    TMMGroup = null;
                }
                break;
        }

        NotifyRemovedFromQueue();
    }

    private static string GetMapName(TMMGameType gameType)
    {
        return gameType switch
        {
            TMMGameType.MIDWARS => "midwars",
            TMMGameType.RIFTWARS => "riftwars",
            TMMGameType.CAMPAIGN_NORMAL => "caldavar",
            TMMGameType.NORMAL => "caldavar",
            TMMGameType.CAMPAIGN_CASUAL => "caldavar_old",
            TMMGameType.CASUAL => "caldavar_old",
            TMMGameType.REBORN_UNRANKED_NORMAL => "caldavar_reborn",
            TMMGameType.REBORN_UNRANKED_CASUAL => "caldavar_reborn",
            _ => "unknown#" + gameType,
        };
    }

    public void InviteAccount(ChatServerProtocol.ChatClientStatus initiatorStatus, byte initiatorFlags, Account initiator, Account invitee)
    {
        if (KongorContext.ConnectedClients.TryGetValue(invitee.AccountId, out ConnectedClient? client))
        {
            InvitedAccountIds.Add(invitee.AccountId);

            // Send invite to the player.
            client.SendResponse(new MatchmakingGroupInviteResponse(
                initiatorAccountName: initiator.Name,
                initiatorAccountId: initiator.AccountId,
                initiatorStatus: initiatorStatus,
                initiatorFlags: initiatorFlags,
                initiatorChatNameColour: initiator.SelectedChatNameColourCode,
                initiatorAccountIcon: initiator.SelectedAccountIconCode,
                initiatorAscensionLevel: initiator.AscensionLevel,
                mapName: GetMapName(GameType),
                gameType: GameType,
                gameModes: GameModes,
                regions: Regions
            ));

            // Let the group know what's happening.
            Broadcast(new MatchmakingGroupInviteBroadcast(
                inviteeAccountName: invitee.Name,
                initiatorAccountName: initiator.Name
            ));
        }
    }

    public void RejectInvite(Account account)
    {
        // TODO: broadcast rejection to the group.
        InvitedAccountIds.Remove(account.AccountId);
    }

    public bool AcceptInvite(Account account, out ChatServerProtocol.MatchmakingFailedToJoinReason failureReason)
    {
        if (InvitedAccountIds.Remove(account.AccountId))
        {
            return Add(account, out failureReason);
        }

        // Account wasn't invited to this group.
        failureReason = ChatServerProtocol.MatchmakingFailedToJoinReason.WrongPassword;
        return false;
    }

    public void SetGroupType(byte groupType)
    {
        // Note: this call is always followed by UpdateGameOptions(),
        // so no need to perform BroadcastUpdate().
        GroupType = groupType;
    }

    public void UpdateGameOptions(TMMGameType gameType, string gameModes, string regions, byte ranked, byte matchFidelity, byte botDifficulty, byte randomizeBots)
    {
        // Cannot update group settings while in queue.
        if (State != GroupState.InQueue)
        {
            GameType = gameType;
            GameModes = gameModes;
            Regions = regions;
            Ranked = ranked;
            MatchFidelity = matchFidelity;
            BotDifficulty = botDifficulty;
            RandomizeBots = randomizeBots;

            BroadcastUpdate(GroupUpdateType.Full);
        }
    }

    public void NotifyGameServerFound()
    {
        Broadcast(new MatchmakingGroupQueueUpdateResponse(
            updateType: 16, // Queue Update Magic Number #2. Indicates match found.
            averageTimeInQueueInSeconds: 0 // Ignored.
        ));
    }

    public void NotifyGameServerReady(byte matchType, int matchId, string address, short port)
    {
        AutoMatchConnectBroadcast autoMatchConnectBroadcast = new AutoMatchConnectBroadcast(
            matchType: matchType,
            matchId: matchId,
            address: address,
            port: port,
            unknown1: new Random().Next()
        );
        Broadcast(autoMatchConnectBroadcast);
    }

    private void Broadcast(ProtocolResponse response)
    {
        // Use .ToList() to avoid modification-while-iterating issue if Participant is no longer online.
        foreach (Participant participant in Participants.ToList())
        {
            ConnectedClient client = KongorContext.ConnectedClients[participant.AccountId];
            client.SendResponse(response);
        }
    }

    private void BroadcastUpdate(GroupUpdateType updateType)
    {
        BroadcastUpdate(updateType, 0);
    }

    private void BroadcastUpdate(GroupUpdateType updateType, int removedOrKickedAccountId)
    {
        List<Participant> participantsListCopy = Participants.ToList();
        foreach (Participant participant in participantsListCopy)
        {
            byte[] friendshipStatus = new byte[participantsListCopy.Count];
            for (int i = 0; i < participantsListCopy.Count; ++i)
            {
                friendshipStatus[i] = Convert.ToByte(AreFriends(participant, participantsListCopy[i]));
            }

            MatchmakingGroupUpdateResponse matchmakingGroupUpdateResponse = new MatchmakingGroupUpdateResponse(
                updateType: Convert.ToByte(updateType),
                accountId: removedOrKickedAccountId,
                groupSize: Convert.ToByte(participantsListCopy.Count),
                averageTMR: Convert.ToInt16(1500),
                leaderAccountId: Participants[0].AccountId,
                unknown1: 1, // 1 for ranked, 4 midwars, 5 bot, 7 riftwars? Possibly wrong.
                gameType: GameType,
                mapName: GetMapName(GameType),
                gameModes: GameModes,
                regions: Regions,
                ranked: Ranked,
                matchFidelity: MatchFidelity,
                botDifficulty: BotDifficulty,
                randomizeBots: RandomizeBots,
                unknown2: "",
                playerInvitationResponses: "", // seems important.
                teamSize: 5, // max number of players?
                groupType: GroupType,
                groupParticipants: CreateGroupParticipants(),
                friendshipStatus: friendshipStatus
            );

            if (KongorContext.ConnectedClients.TryGetValue(participant.AccountId, out var client))
            {
                client!.SendResponse(matchmakingGroupUpdateResponse);
            }
        }
    }

    private List<MatchmakingGroupUpdateResponse.GroupParticipant> CreateGroupParticipants()
    {
        List<MatchmakingGroupUpdateResponse.GroupParticipant> groupParticipants = new();
        for (int i = 0; i < Participants.Count; ++i)
        {
            groupParticipants.Add(CreateGroupParticipant(i, Participants[i]));
        }
        return groupParticipants;
    }

    private MatchmakingGroupUpdateResponse.GroupParticipant CreateGroupParticipant(int slot, Participant participant)
    {
        bool isReady;
        if (participant == Participants[0])
        {
            // Leader is Ready when they advance the state.
            isReady = State != GroupState.WaitingToStart;
        }
        else
        {
            // Non-Leaders are always ready.
            isReady = true;
        }
        return new MatchmakingGroupUpdateResponse.GroupParticipant(
            AccountId: participant.AccountId,
            Name: participant.Name,
            Slot: Convert.ToByte(slot),
            NormalRankLevel: 1500,
            CasualRankLevel: 1500,
            NormalRanking: 5,
            CasualRanking: 5,
            EligibleForCampaign: 1,
            Rating: 1500,
            LoadingPercent: participant.LoadingStatus,
            ReadyStatus: Convert.ToByte(isReady),
            InGame: 0,
            Verified: 1,
            ChatNameColor: participant.ChatNameColor, // not sure if this works.
            AccountIcon: participant.AccountIcon,
            Country: "US", // ??
            GameModeAccessBool: 1,
            GameModeAccessString: GameModes // game modes that user can access?
        );
    }

    private bool AreFriends(Participant participant1, Participant participant2)
    {
        // TODO: implement.
        return false;
    }

    private void OnTimerCallback()
    {
        using PerformanceCounter performanceCounter = new PerformanceCounter();
        performanceCounter.Category = "MatchmakingGroup";
        performanceCounter.Subcategory = "OnTimerCallback";

        if (State == GroupState.LoadingResources)
        {
            // Update LoadingProgress progress.
            BroadcastUpdate(GroupUpdateType.Partial);
        }

        performanceCounter.FinishCollection();
    }

    private List<Dictionary<int, int>> GetPerPlayerPingInformation()
    {
        List<Dictionary<int, int>?> result = new();
        foreach (var participant in Participants)
        {
            result.Add(KongorContext.ConnectedClients[participant.AccountId].PingInformation);
        }
        return result;
    }

    public static Dictionary<int, int> CombinePingInformation(List<Dictionary<int, int>> pingInformations)
    {
        int numParticipants = pingInformations.Count;
        if (numParticipants == 0)
        {
            // Nothing else to do if there is only one participant in the group.
            return pingInformations[0];
        }

        // Group ping information.
        Dictionary<int, int> pingInformation = new();

        // Start with first player.
        Dictionary<int, int> firstPlayerPingInformation = pingInformations[0];

        // Iterate through all managers.
        foreach (KeyValuePair<int, int> entry in firstPlayerPingInformation)
        {
            int managerId = entry.Key;

            // Add up all pings.
            int maxPing = entry.Value;
            for (int i = 1; i < numParticipants; ++i)
            {
                if (pingInformations[i].TryGetValue(managerId, out int ping))
                {
                    maxPing = Math.Max(ping, maxPing);
                }
            }

            pingInformation[managerId] = maxPing;
        }

        return pingInformation;
    }

    private static void TimerCallback(object? state)
    {
        MatchmakingGroup? matchmakingGroup = state as MatchmakingGroup;
        if (matchmakingGroup == null) return;

        try
        {
            lock (typeof(ChatServer))
            {
                matchmakingGroup.OnTimerCallback();
            }
        }
        catch (Exception e)
        {
            Console.WriteLine("TimerCallback exception: {0}", e.ToString());
        }
    }

    private HashSet<string> SplitByPipeAndRemoveEmpty(string pipeSeparatedString)
    {
        HashSet<string> strings = new();
        foreach (string s in pipeSeparatedString.Split('|'))
        {
            if (s.Length != 0) strings.Add(s);
        }
        return strings;
    }
}
